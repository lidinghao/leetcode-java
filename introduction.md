# 介绍
# 算法与数据结构
数据结构是为了满足算法有效访问数据访问的要求。
#数学知识
卡特兰数
#基本运算

##关于数的各种操作技巧
得到整数的基（即十进制位数）
```java
int d = 1; //与x同位数的整数,如x = 312, d =100
int k = 1; //x的位数，如x=321,k=3
while(x/d >= 10){
  d *= 10;
  k++;
}
```


# 线性表
## 链表
### 判断链表是否有环
#### 分析
第一反应是遍历链表，并用HashMap将访问过的节点记录下来，如果出现重复访问，则说明有环，这样的时间复杂度是O(N),空间复杂度也是O(N)。
另外一种方式就是设置快慢两个指针，p1和p2,一开始都指向表头，p1每次移动一步，p2每次移动两步，如果p1和p2相遇，则说明有环。
代码如下：

# 树
# 图
# 排序
## 排序算法的实际实现（Arrays.sort源码分析）
我们将使用迭代改进的方式来描述现实中排序算法的实现，主要参考java中的Arrays.sort源码。
baseline是quicksort，然后在此基础上，进行迭代改进。
#Out-of-Core算法
排序、查找、join

##100 亿个数字中找出最大的 1000 个
这是最基本问题了，答案是用堆，但是用大根堆，还是小根堆，是有区别的。
正确答案是用小根堆，首先读取前1000个数，建立一个1000元素的小根堆，然后每次读取一个新的数，将其与堆顶的元素（即目前扫描的数中最大的1000元素中最小的，即第1000大的）比较，如果新元素比堆顶元素大，则删除堆顶元素，插入新元素，调整堆，否则什么也不做。
相反，同理，如果是找出最小的1000，则采用大根堆。

##用2G内存对10亿数进行排序
这类大数据排序，或大数据统计（找出top-K， Middle-K）都要利用分治的思想，或空间搜索的思想一步步缩小搜索空间。
大数据排序，基本上是利用归并排序，先把文件分成很多块，然后对每块进行排序，然后进行归并。

##Internal Sort
Quicksort 
Tournament Sort

##利用找出40亿个非负整数中出现两次的数
 利用Bitmap来压缩空间，32位无符号整数为0 ~ 4294967295, 而0-3次可以用2个bit表示（因为要求两次，所以至少要有0,1,2,3四种状态）。所以可以利用4294967295 * 2 个比特位的空间， 即 (2^32 * 2) / 8 = 1GB的内存来完成运算。 
 
 ##找出100亿中重复的URL
 利用hash函数的特性和divide and conquer算法，对于相同输入，任何hash函数值也相同，反之不一定，（不过话说所有函数都有这个特性吧？）。可以hash函数吧URLdivide到各个比较小的文件，然后分而治之。

##找出100亿个整数的中位数（或者进行其他区间统计）
利用桶排序，将数据按大小归类，放到不同的桶中，然后找出中位数所在的那个桶，然后再对通过进行进一步的桶排序，当剩余数小到一定时候，就可以选用内存排序了。
其实是一个逐步缩小搜索空间的过程。

#B-tree 、B+ tree、 B-link tree

#动态规划
##找零钱
####换钱的最少货币数
1.给一组不同面值的货币，一个金额M，求组成M的最少货币数，其中，每种面值的货币都可以使用任意张。
2.给给一组各种面值的货币（里面可能有相同面值的货币），一个金额M，求组成M的最少货币数，其中，每个货币只能使用一次。

####换钱的方法数
3.给一组不同面值的货币，一个金额M，求组成M的最少货币数，其中，每种面值的货币都可以使用任意张。
##0-1背包问题
找零钱和背包问题有很多共同之处。
##动态规划的实际应用
##join optimization
#字符串匹配
##KMP算法
给定两个字符串str和pattern,长度分别为N,M。实现一个算法，如果字符串str中含有子串pattern,则返回pattern在str中的开始位置，不含则返回-1。
简单KMP，时间复杂度为O(n),空间复杂度为O(M\*A),A为字符的数目，英语为26。
解法:首先，对pattern构建一个自动机，用26\*M的数组来表示一个自动机。构建自动机的步骤很巧妙，在构造自动机的过程中，利用目前的自动机来构造下一步自动机。
#10. Regular Expression Matching
##分析
首先第一印象是采用递归的方式，首先匹配str[i]与exp[j]，然后再递归匹配str[i+1...]与exp[j+1...]。如果exp[j+1]是普通字符串或"."的话，上面的递归显然是正确的。但如果exp[j+1]是"\*"的话，上面的递归就不正确了。例如，str="aabc",exp="a\*bc",结果应该是true,但是按上面的递归会在i=0,j=0后,匹配str[1..]和exp[1...],显然会返回错误结果。

因此我们要读"\*"特殊处理，"\*"的特殊性在于，它会匹配或者叫消耗0或多个str[i]字符。因此当exp[j+1] == "\*", 要采用backtracking的方式，对所有情况（"\*"匹配0到n-i个）进行尝试，如果有一种情况能返回true,则整个匹配就返回true。
因此，代码如下：
