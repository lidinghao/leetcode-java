# 大数据算法

##topK问题
###100 亿个数字中找出最大的 1000 个
这是最基本问题了，答案是用堆，但是用大根堆，还是小根堆，是有区别的。
正确答案是用小根堆，首先读取前1000个数，建立一个1000元素的小根堆，然后每次读取一个新的数，将其与堆顶的元素（即目前扫描的数中最大的1000元素中最小的，即第1000大的）比较，如果新元素比堆顶元素大，则删除堆顶元素，插入新元素，调整堆，否则什么也不做。
相反，同理，如果是找出最小的1000，则采用大根堆。
## Out-of-Core算法
排序、查找、join
### 用2G内存对10亿数进行排序
这类大数据排序，或大数据统计（找出top-K， Middle-K）都要利用分治的思想，或空间搜索的思想一步步缩小搜索空间。
大数据排序，基本上是利用归并排序，先把文件分成很多块，然后对每块进行排序，然后进行归并。

##Internal Sort
Quicksort 
Tournament Sort

### 利用找出40亿个非负整数中出现两次的数
 利用Bitmap来压缩空间，32位无符号整数为0 ~ 4294967295, 而0-3次可以用2个bit表示（因为要求两次，所以至少要有0,1,2,3四种状态）。所以可以利用4294967295 * 2 个比特位的空间， 即 (2^32 * 2) / 8 = 1GB的内存来完成运算。 
 
 ### 找出100亿中重复的URL
 利用hash函数的特性和divide and conquer算法，对于相同输入，任何hash函数值也相同，反之不一定，（不过话说所有函数都有这个特性吧？）。可以hash函数吧URLdivide到各个比较小的文件，然后分而治之。

### 找出100亿个整数的中位数（或者进行其他区间统计）
利用桶排序，将数据按大小归类，放到不同的桶中，然后找出中位数所在的那个桶，然后再对通过进行进一步的桶排序，当剩余数小到一定时候，就可以选用内存排序了。
其实是一个逐步缩小搜索空间的过程。

